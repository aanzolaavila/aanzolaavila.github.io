<!doctype html><html lang=en><head><title>What I Learned From Hash Functions :: Terminal</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In here I try to explain hash functions as best as I can, with some math that are usually not mentioned in any common cybersecurity course."><meta name=keywords content=","><meta name=robots content="noodp"><link rel=canonical href=https://aanzolaavila.github.io/posts/what-i-learned-from-hash-functions/><link rel=stylesheet href=https://aanzolaavila.github.io/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://aanzolaavila.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://aanzolaavila.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="What I Learned From Hash Functions"><meta property="og:description" content="In here I try to explain hash functions as best as I can, with some math that are usually not mentioned in any common cybersecurity course."><meta property="og:url" content="https://aanzolaavila.github.io/posts/what-i-learned-from-hash-functions/"><meta property="og:site_name" content="Terminal"><meta property="og:image" content="https://aanzolaavila.github.io"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-08-17 23:26:38 -0500 -0500"><style>.has-mathjax{visibility:hidden}</style><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script>window.MathJax={startup:{pageReady:()=>MathJax.startup.defaultPageReady().then(()=>{for(let e of document.getElementsByClassName("has-mathjax"))e.style.visibility="visible"})}}</script></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>aanzolaavila</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/publications>Publications</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/publications>Publications</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://aanzolaavila.github.io/posts/what-i-learned-from-hash-functions/>What I Learned From Hash Functions</a></h1><div class=post-meta><span class=post-date>2022-08-17</span>
<span class=post-author>:: Alejandro Anzola-√Åvila</span>
<span class=post-reading-time>:: 6 min read (1253 words)</span></div><span class=post-tags>#<a href=https://aanzolaavila.github.io/tags/hash/>hash</a>&nbsp;
#<a href=https://aanzolaavila.github.io/tags/security/>security</a>&nbsp;
#<a href=https://aanzolaavila.github.io/tags/cryptography/>cryptography</a>&nbsp;
#<a href=https://aanzolaavila.github.io/tags/computerscience/>computerscience</a>&nbsp;</span><div class=post-content><div><p>During 2019-2 semester I had the opportunity to do a research exchange to the US, did some research on Blockchain technologies and took a course on <em>Applied Cryptography</em>.</p><p>While I am not going to talk about Blockchain in here, I will talk about Cryptography, hash functions in particular. Before this, I had a very limited idea of a lot of the concepts that are required from hash functions.</p><p>Before going there I only had the brief idea that a hash function is a one-way function. Roughfly that you can calculate its output from the input easily, but you cannot get the input from the output.</p><p>And with that definition it was enough to know that a lot of security applications rely deeply on them, and a lot of things would not be possible without them, such as Blockchain. But still I had no idea of what they needed to fulfill to be considered a good hash function.</p><p>So, without further ado, I&rsquo;ll dive in.</p><hr><h1 id=hash-function>Hash function<a href=#hash-function class=hanchor arialabel=Anchor>&#8983;</a></h1><blockquote><p>A hash function is a one-way function <span class=has-mathjax>\( h \)</span>
such that for a given input <span class=has-mathjax>\( x\in\{0, 1\}^{n} \)</span>
, also called as <em>pre-image</em>, gives an output <span class=has-mathjax>\( y\in\{0, 1\}^{d} \)</span>
, also known as <em>image</em>, where <span class=has-mathjax>\( n \)</span>
is of any size and <span class=has-mathjax>\( d \)</span>
is a constant, both are number of bits.</p></blockquote><div class=has-mathjax>\[ y = h(x) \]</div><hr><h1 id=properties>Properties<a href=#properties class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Now, an ideal hash function has many security properties, but the need for each of them goes mainly on what use it is going to get.</p><h2 id=pre-image-resistance-pr>Pre-image resistance (PR)<a href=#pre-image-resistance-pr class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>Given the output <span class=has-mathjax>\( y \)</span>
, it is <strong>infeasible</strong> to find any input <span class=has-mathjax>\( x \)</span>
such that <span class=has-mathjax>\( h(x) = y \)</span>
.</p></blockquote><p>This means that knowing the output <span class=has-mathjax>\( y \)</span>
and the hash function <span class=has-mathjax>\( h \)</span>
it takes a lot of work to find an input that gives us that same output.</p><p>The term <em>infeasible</em> in here refers to the fact that you would need <strong>a lot</strong> of computer power to get the input, and that input may not be equal to the one that actually gave that output in the first place.</p><hr><h2 id=infeasibility>Infeasibility<a href=#infeasibility class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The size of the output <span class=has-mathjax>\( d \)</span>
should be big enough to make any attacker do at least <span class=has-mathjax>\( 2^{112} \)</span>
attempts of work to break it. <em>This value could change in the future as computer computing capability is increasing</em>.</p><p>Furthermore, these properties make the problem even more difficult.</p><ul><li><p>The output of <span class=has-mathjax>\( h \)</span>
is uniform<br>The probability of each bit on <span class=has-mathjax>\( y \)</span>
to be either 0 or 1 is 1/2.</p><div class=has-mathjax>\[ \forall i \in \{1, \ldots, d\} ,\; P(y_i = 1) = P(y_i = 0) = \frac{1}{2} \]</div></li><li><p>Avalanche effect<br>Given inputs <span class=has-mathjax>\( x_1, x_2 \)</span>
such that <span class=has-mathjax>\( x_1 \approxeq x_2 \)</span>
then
<span class=has-mathjax>\[ h(x_1) \neq h(x_2) \]</span>
They should differ in at least 50% of the output bits. <em>It should be sufficient to change just one bit.</em></p></li><li><p>The probability <span class=has-mathjax>\( P(\text{output} = \text{a specific output}) = \frac{1}{2^d} \)</span></p></li></ul><hr><h2 id=collision-resistance-cr>Collision Resistance (CR)<a href=#collision-resistance-cr class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>It is <em>infeasible</em> to find any <span class=has-mathjax>\( x, x^{\prime} \)</span>
such that <span class=has-mathjax>\( h(x) = h(x^{\prime}) \)</span></p></blockquote><p>This means that we only know the function <span class=has-mathjax>\( h \)</span>
, an that is it. It should be very hard to find any pair of different inputs such that they are equal.</p><hr><h2 id=weak-collision-resistance-wcr>Weak Collision Resistance (WCR)<a href=#weak-collision-resistance-wcr class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>Given an input <span class=has-mathjax>\( x \)</span>
, it is <em>infeasible</em> to find <span class=has-mathjax>\( x^{\prime} \neq x \)</span>
such that <span class=has-mathjax>\( h(x^{\prime}) = h(x) \)</span></p></blockquote><p>This problem is similar to CR, but it has a key difference: <em>we know one of the inputs</em>, and we are tasked to find another input such that their outputs are equal.</p><p>It may seem counter-intuitive, but this problem is harder than CR.</p><hr><p>Assuming that the hash function used is well designed to take all of these properties into consideration, a good question to ask would be: what is the minimum size <span class=has-mathjax>\( d \)</span>
from the output to guarantee all of them?</p><p>The answer depends on each property, let&rsquo;s start with PR. Assume that we run <span class=has-mathjax>\( h \)</span>
with <span class=has-mathjax>\( m \)</span>
different inputs. How many pre-images will we find?</p><p>Remember, we want an attacker to at least to <span class=has-mathjax>\( 2^{112} \)</span>
attempts.</p><p>How many do we need to get at least one pre-image?<div class=has-mathjax>\[ \mathop{\mathbb{E}}[\text{# of pre-images}] = (\text{number of chances}) \times (\text{probability of a chance}) \]</div></p><div class=has-mathjax>\[ 1 = m \times \frac{1}{2^{d}} \]</div><div class=has-mathjax>\[ m = 2^{d} \]</div><p>[<span class=has-mathjax>\( m \)</span>
should be at least <span class=has-mathjax>\( 2^{112} \)</span>
]</p><div class=has-mathjax>\[ 2^{112} = 2^{d} \]</div><div class=has-mathjax>\[ d \ge 112 \]</div><hr><p>Similarly, to get the value for CR, lets do this:</p><p>Pick a random <span class=has-mathjax>\( x_{i} \in \{0, 1\}^{\ast} \)</span>
, compute <span class=has-mathjax>\( y_{i} = h(x_{i}) \)</span>
, store <span class=has-mathjax>\( y_{i} \)</span>
. Does it match any previous <span class=has-mathjax>\( y_{i} \)</span>
? If yes, then halt. Repeat <span class=has-mathjax>\( m \)</span>
times.</p><div class=has-mathjax>\[ \mathop{\mathbb{E}}[\text{# of collitions}] = (\text{number of chances}) \times (\text{probability of a chance}) \]</div><div class=has-mathjax>\[ \mathop{\mathbb{E}}[\text{# of collitions}] = \binom{m}{2} \times \frac{1}{2^{d}} \]</div><div class=has-mathjax>\[ \mathop{\mathbb{E}}[\text{# of collitions}] = \frac{m(m-1)}{2} \times \frac{1}{2^{d}} \]</div><p>[We want at least one collision]</p><div class=has-mathjax>\[ 1 = \frac{m(m-1)}{2} \times \frac{1}{2^{d}} \]</div><p>[Lets simplify the problem approximating the result]</p><div class=has-mathjax>\[ 1 \approx \frac{m^{2}}{2^{d}} \]</div><div class=has-mathjax>\[ m^{2} = 2^{d} \]</div><div class=has-mathjax>\[ m = 2^{d/2} \]</div><div class=has-mathjax>\[ 2^{112} = 2^{d/2} \]</div><div class=has-mathjax>\[ d \ge 224 \]</div><hr><p>Since WCR is a harder problem than CR, then lets set <span class=has-mathjax>\( d \ge 112 \)</span>
.</p><p>Long story short, we have this constraints for each property:</p><ul><li>No PR, No CR, and No WCR<br><span class=has-mathjax>\( d \ge 1 \)</span></li><li>PR, No CR, and WCR<br><span class=has-mathjax>\( d \ge 112 \)</span></li><li>PR, CR, and WCR<br><span class=has-mathjax>\( d \ge 224 \)</span></li></ul><hr><h2 id=bonus>Bonus<a href=#bonus class=hanchor arialabel=Anchor>&#8983;</a></h2><p>There is an additional property not often discussed: <strong>Non-malleability</strong>.</p><blockquote><p>Given <span class=has-mathjax>\( y = h(x) \)</span>
, it should be <em>infeasible</em> to compute:<div class=has-mathjax>\[ y^{\prime} = h(f(x)) \]</div>Such that <span class=has-mathjax>\( y = y^{\prime} \)</span>
, where <span class=has-mathjax>\( f \)</span>
is a simple function, such as <span class=has-mathjax>\( h(x+1) ; h(2x) \)</span>
.</p></blockquote><p>Not every hash function has this property.</p><p>Turns out that there is two known types of hash functions with different types of contruction: Markle-Dangard construction (MD5, SHA-1, SHA2), and Sponge construction (SHA3).</p><p>Markle-Dangard computes the hash iteratably with blocks, processing a chunk of the input information at a time, meaning that an input is <span class=has-mathjax>\( m = m_{1} || m_{2} || \cdots || m_{l} \)</span>
, therefore, the hash function iterates through it like this <span class=has-mathjax>\( y_{i} = h(y_{i-1}, m_{i}) \)</span>
and <span class=has-mathjax>\( h(m) = y_{l} \)</span>
, each block is a fixed size, if the input size is not a multiple of the block size, there is a padding added at the end that does not alter the output of the entire function (i.e. a bunch of zeros to complete the block).</p><p>In particular, Markle-Dangard construction is susceptible to a Length Extension Attack (LEA), which comes from that padding, in particular if we give the hash function more blocks that are filled with zeroes, it will yield the same result</p><div class=has-mathjax>\[ h(m_{1} || \cdots || m_{l}) = h(m_{1} || \cdots || m_{l} || \text{0000000}) \]</div><p>Meaning <span class=has-mathjax>\( y = y^{\prime} \)</span>
, violating the property.</p><hr><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>&#8983;</a></h2><p>This was an interesting post to write, not only I wrote about something that I find very interesting, but also something that may be useful/interesting to someone else that may find it, I&rsquo;m pretty sure I would have loved to find this kind of explanations when I was first dwelving into these subjects.</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>¬© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://aanzolaavila.github.io/assets/main.js></script>
<script src=https://aanzolaavila.github.io/assets/prism.js></script></div></body></html>